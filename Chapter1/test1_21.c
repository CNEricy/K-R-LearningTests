//
// Created by Hello on 2021/9/10.
//

/**
 * 主要思路:
 * 由于tab是补足8位,即记8个字符为一组,将末尾的空格转为制表符即可
 */

#include <stdio.h>

#define TABSPACE 8

int main(void)
{
    //Q1
    int c, len; //len:记录一组字符串中字符的个数
    char ch[TABSPACE + 1];  //8个字符为一组,+1存放'\0'

    len = 0;
    while ((c = getchar()) != EOF) {
        ch[len] = c;
        ++len;
        if (len == TABSPACE || c == '\n') { //当一组满了或者遇到换行符,一组输入完成
            ch[len] = '\0';
            /*从后往前,当遇到空格将其替换为'\t',当下一个还是空格时,需要将后面的赋值成'\0',只保留一个'\t'
             *当遇到非空格字符或全为空格(已转换成一个'\t'),打印字符串,一组完成,长度从0开始
             */
            for (int i = len - 1; i >= 0; --i) {
                if (ch[i] == ' ') {
                    ch[i] = '\t';
                    ch[i + 1] = '\0';
                } else {
                    printf("%s", ch);
                    len = 0;  //若这里长度不变成0,则会打印多次,若字符串前中部有空格则会被替换成'\t'
                    break;
                }

                if (i == 0)
                {
                    printf("%s",ch);
                    /*
                     * 若这里长度不变成0,会打印"两次换行符"且则可能会出现字符被"吞噬"的情况,这是由于进入下一次while循环后,len还是之前的值,但此时,
                     * 数组中的情况: {'\t','\0','\0'...,'下(下)一组字符1'....},注意,这里"下(下)一组字符"会继续添加至之前一次的数组末尾,可能会出现越界情况,但是仍旧可以编译运行
                     * 由于printf打印字符串时遇到第一个'\0'就停止,后面的字符就不会再展示
                     * 当打印完第二个换行符后,len被置为0,又再次恢复正常,直到再遇到全为空格的情况重复上述问题
                     */
                    len = 0;
                }
            }
        }
    }

    //Q2:制表符(tab)? 举例:英文名中的间隔默认为空格?这样当多个英文名并列时,可以用制表符分割
}